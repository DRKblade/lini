// Look for the referenced key
if (auto index = doc.find(new_sec, new_key); index) {
  // Found it
  auto& ref_val = doc.values[*index];
  value.reset();

  // Check for cyclical linking
  if (!ref_val) {
    return "Cyclical referencing detected";
  } else {
    return parse_key(doc, err, new_sec, new_key, ref_val);

    // Don't make a local_ref to another local_ref, reference directly to its source
    if (auto local = dynamic_cast<local_ref*>(ref_val.get()); local != nullptr)
      value = std::make_unique<local_ref>(local->ref);
    else
      value = std::make_unique<local_ref>(ref_val);
  }
} else if (fallback) {
  value = move(fallback);
} else
  return "Referenced key doesn't exist: " + new_sec + "." + new_key;
